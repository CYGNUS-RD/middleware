diff --git a/conf/kafka/dev/consumer-event.py b/conf/kafka/dev/consumer-event.py
index 4191d47..a3fd692 100755
--- a/conf/kafka/dev/consumer-event.py
+++ b/conf/kafka/dev/consumer-event.py
@@ -12,13 +12,11 @@ import midas
 import pandas as pd
 import mysql.connector
 from datetime import datetime
-import time
 
 import cygno as cy
 
 import os
 import sys
-TAG="LNF"
 
 def get_script_path():
     return os.path.dirname(os.path.realpath(sys.argv[0]))
@@ -33,8 +31,6 @@ def image_jpg(image, vmin, vmax, event_number, event_time):
     plt.savefig('/tmp/tmp.png')
     with open('/tmp/tmp.png', 'rb') as f:
         img_bytes = f.read()
-    f.close()
-    
     img_base64 = base64.b64encode(img_bytes).decode('utf-8')
     # create json object
     data = {'image': img_base64}
@@ -43,58 +39,72 @@ def image_jpg(image, vmin, vmax, event_number, event_time):
     fpath = get_script_path()
     with open(fpath+'/plot.json', 'w') as f:
         json.dump(data, f)
-    f.close()
-    plt.close()
-    del im, img_bytes, img_base64, data, image
+        
     return 
 
 
 
-def main(verbose=False):
+def main(TAG, verbose=False):
     vmin         = 95
     vmax         = 130
     connection   =-1
 
     consumer = KafkaConsumer(
-        'midas-event'+TAG,
-        bootstrap_servers=['localhost:9092'], 
-        auto_offset_reset='latest',
+        bootstrap_servers=["localhost:9092"],
+        group_id="demo-group",
+        auto_offset_reset="earliest",
         enable_auto_commit=True,
-        group_id='online-event',
+        fetch_max_bytes = 31457280,
         max_partition_fetch_bytes = 31457280,
-     #   value_deserializer=lambda x: loads(x.decode('utf-8'))
-     #   value_deserializer=lambda x: dumps(x).decode('utf-8')
+        consumer_timeout_ms=1000
+
     )
+    topic = 'midas-event-'+TAG
     # reset to the end of the stream
     # consumer.poll()
     # consumer.seek_to_end()
     #
     event = midas.event.Event()
+    consumer.subscribe(topic)
+    
+    
+    while True:
+        try:
+            for message in consumer:
+                binary_data = io.BytesIO(message.value)
+                decoded_data = binary_data.read()
+                payload = decoded_data
+                event.unpack(payload, use_numpy=False)
+#                 bank_names = ", ".join(b.name for b in event.banks.values())
 
-    for msg in consumer:
-        binary_data = io.BytesIO(msg.value)
-        decoded_data = binary_data.read()
-        pyload = decoded_data
-        event.unpack(pyload, use_numpy=False)
-        
-        bank_names    = ", ".join(b.name for b in event.banks.values())
-        event_number  = event.header.serial_number
-        event_time    = datetime.fromtimestamp(event.header.timestamp).strftime('%Y-%m-%d %H:%M:%S')
-        
-        print("received {:.1f} timestem: {:d}".format( len(msg.value)/1024/1024, event.header.timestamp))
+#                 bank_names    = ", ".join(b.name for b in event.banks.values())
+#                 event_info    = [event.header.timestamp, event.header.serial_number, event.header.event_id]
+#                 event_number  = event.header.serial_number
+#                 event_time    = datetime.fromtimestamp(event.header.timestamp).strftime('%Y-%m-%d %H:%M:%S')
+#                 if verbose: print (event_info, bank_names)
+#                 if ('CAM0' in bank_names):
+#                     image, _, _ = cy.daq_cam2array(event.banks['CAM0']) # matrice delle imagine
+#                     image_jpg(image, vmin, vmax, event_number, event_time)
 
-        if ('CAM0' in bank_names):
-            s = time.time()
-            image, _, _ = cy.daq_cam2array(event.banks['CAM0']) # matrice delle imagine
-            e1 = time.time()
-            image_jpg(image, vmin, vmax, event_number, event_time)
-            e= time.time()
-            print("{:.1f} s {:.1f} s".format(e-e1, e1-s))
+                if verbose:
+                    topic_info = f"topic: {message.partition}|{message.offset})"
+                    message_info = f"key: {message.key}, {message.value}"
+                    print(f"{topic_info}")
+
+        except Exception as e:
+            print(f"Error occurred while consuming messages: {e}")
+            sys.exit(1)
+        except KeyboardInterrupt:
+            sys.exit(0)
+            consumer.close()
+        
         
+                
         
 if __name__ == "__main__":
     from optparse import OptionParser
     parser = OptionParser(usage='usage: %prog\t ')
+    parser.add_option('-t','--tag', dest='tag', type='string', default='LNGS', help='tag LNF/LNGS [LNGS];');
     parser.add_option('-v','--verbose', dest='verbose', action="store_true", default=False, help='verbose output;');
     (options, args) = parser.parse_args()
-    main(verbose=options.verbose)
+    main(TAG=options.tag, verbose=options.verbose)
